class Solution {
    public:
       void findCombination(int ind,string &temp,vector<string> &ans,string &s,unordered_map<char,string> &map)
       {
           //base case
             if(ind==s.size()){
                 ans.push_back(temp);
                 return;
             }
            string str=map[s[ind]];  //map[2]--> this will return the "abc"
            for(int i=0;i<str.size();i++)
            {
                temp.push_back(str[i]);
                findCombination(ind+1,temp,ans,s,map);  
                temp.pop_back(); 
            }
       }
public:
    vector<string> letterCombinations(string digits) {
         vector<string> ans;
        // edge case 
        if(digits.size()==0)
          return ans;

        unordered_map<char, string> map = {
            {'2', "abc"},
            {'3', "def"},
            {'4', "ghi"},
            {'5', "jkl"},
            {'6', "mno"},
            {'7', "pqrs"},
            {'8', "tuv"},
            {'9', "wxyz"}
        };
       
        string temp="";
        findCombination(0,temp,ans,digits,map);
        return ans;
    }
};

Complexity

Time complexity:

The time complexity of this approach is O(4^n) where n is the number of digits in the input string.
This is because each digit can map to up to 4 letters in the worst case, and there are n digits in the input.

Space complexity: 

The space complexity is O(n) as we are using recursion and the maximum depth of the recursion is n.
Additionally, we are using a result list to store the combinations, which can also take up to O(n) space in the worst case.








